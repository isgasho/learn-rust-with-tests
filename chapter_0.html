<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 0: Hello, world - Learn Rust With TDD</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_0.html" class="active"><strong aria-hidden="true">1.</strong> Chapter 0: Hello, world</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Chapter 1: Hello, YOU</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Learn Rust With TDD</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#chapter-0-hello-world" id="chapter-0-hello-world">Chapter 0: Hello, world!</a></h1>
<p>In this chapter, as is traditional, we'll introduce Rust by printing &quot;Hello,
world!&quot; to the screen. Along the way we'll look at how to set up a Rust project
using Cargo, what the files</p>
<p>Let's start a new Rust project. If we've already installed Rust and Cargo, this
is as simple as</p>
<pre><code class="language-sh">$ cargo init hello_world
</code></pre>
<p>at the command line.</p>
<p>This will create a new directory, <code>hello_world</code>. The structure within this
folder looks like this:</p>
<pre><code class="language-console">hello_world
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p><code>Cargo.toml</code> contains metadata about the project:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;David Wickes &lt;dave.wickes@gmail.com&gt;&quot;]
edition = &quot;2018&quot;
</code></pre>
<p>This includes information like the name of the package, the authors, which
version of Rust is being used, and any external Rust libraries - crates - that
we're using. We'll look at that in a bit more detail later.</p>
<p>The <code>src</code> directory contains all the Rust code that we're going to write - the
source code! And the <code>main.rs</code> file inside <code>src</code> contains our as yet unwritten
program. Cargo puts a dummy program in there to get us started.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Well, blimey! Looks like Cargo has done all the hard work for us.</p>
<p>To run this program we need to <em>compile</em> the Rust code into something that our
computer can execute - a file called a <em>binary</em> - using a program called
a <em>compiler</em>.</p>
<p>Cargo provides a nice interface to the Rust compiler through the command</p>
<pre><code class="language-sh">$ cargo build
</code></pre>
<p>when we run that inside the <code>hello_world</code> directory we see some output:</p>
<pre><code class="language-sh">Compiling hello_world v0.1.0 (/Users/davidwic/dev/personal/...
 Finished dev [unoptimized + debuginfo] target(s) in 0.40s
</code></pre>
<p>and a new directory called <code>target</code> should appear in your project directory.
This directory contains all the results of compiling your very simple program -
a surprisingly large number of files which are 'intermediate' steps, as well as
a binary file called, unsurprisingly, <code>hello_world</code>.</p>
<p>To run our program we need to execute the binary. We can do this on the command
line like so:</p>
<pre><code class="language-sh">$ ./target/debug/hello_world
</code></pre>
<p>and we should then see:</p>
<pre><code class="language-sh">Hello, world!
</code></pre>
<p>Great success.</p>
<p>To save performing all of the steps above, Cargo provides a command to both
compile and run a program - which is often what we want to do:</p>
<pre><code class="language-sh">$ cargo run
</code></pre>
<p>Which should print out.</p>
<pre><code class="language-sh">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<h2><a class="header" href="#but-where-are-the-tests" id="but-where-are-the-tests">But where are the tests?</a></h2>
<p>This is, after all, <em>Learn Rust With Tests</em>. Where are they?</p>
<p>...</p>
<p>If we want to test the program that ~we~ Cargo wrote for us, we need something
to test. This might sound obvious, but at the moment we don't really have
something that we can have the computer test for us <em>automatically</em>. Our program
is one, admittedly small, lump:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>The first line we can see creates a new <em>function</em> called <code>main</code>. The <code>fn</code>
keyword declares the function, then we can see its name (<code>main</code>), and then we
get a pair of paretheses where we'd put the names of the <em>arguments</em> that the
function recieves - think of these as the input. It's empty because main doesn't
take any inputs!</p>
<p>The <code>main</code> function in Rust is special as it's the 'entry point' for any Rust
program. When your compiled program runs it starts by running the <code>main</code>
function - this is sometimes called 'calling' or 'executing' the function.</p>
<p>Then there's a curly brace <code>{</code>, which is the beginning of the <em>function body</em>.
This is the meat of the function - what actually happens when the function runs.
And in this case:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>println!</code> is not technically function - but it looks and acts like one! It's
actually a <em>macro</em>. We'll look at macros much later. But for now we can think of
it as a function. The function is being called by having a pair of paretheses
after its name.  And it's being called with one argument - one 'thing' inside the parentheses - a <em>string</em> that says <code>&quot;Hello, world!&quot;</code>.</p>
<p>Then comes a closing parenthesis and a semicolon (<code>;</code>). Lines of Rust code
usually end in a semicolon - there's a special reason for this which we'll see
later. And finally a closing curly brace <code>}</code>, which ends the function body.
Whew!</p>
<p>Right now we can only test this program by running it. Which isn't that bad,
really. We can run it quickly and as often as we like, and we can read the
output to see that it says what we expect.</p>
<p>We could even write an automated test in another language - something that runs
the program and compares what it outputs to what we expect. This type of test is
sometimes called an <em>acceptance test</em>. We will look at those later too.</p>
<p>We can only test our program this way because the output is the only <em>interface</em>
we have access to in the program.</p>
<p>At the moment we're trying to test the steering wheel of a car by watching
somebody else drive the car. Wouldn't it be easier if we just got inside the car
and turned the wheel ourself?</p>
<p>To do this we're going to introduce another surface - another interface - to our
program. We're going to test it <em>from the inside</em> of our program to check that
it works. Then we're going to use that interface when the program actually runs
in order to print &quot;Hello, world!&quot;.</p>
<p>Of course, this doesn't guarantee that our program will work. Just as climbing
inside a stationary car, turning the wheel, and watching the wheels turn doesn't
guarantee that the car will actually turn a corner when it's being driven. But
it does give us some confidence that it will.</p>
<h2><a class="header" href="#my-first-test---rust-edition" id="my-first-test---rust-edition">My First Test - Rust Edition</a></h2>
<p>How do you test this? It is good to separate your &quot;domain&quot; code from the outside
world (<em>side effects</em>). The <code>println!</code> is a side effect (printing to stdout) and
the string we send in is our domain.</p>
<p>So let's separate these concerns so it's easier to test.</p>
<pre><pre class="playpen"><code class="language-rust">fn greet() -&gt; String {
    String::from(&quot;Hello, World!&quot;)
}

fn main() {
    println!(&quot;{}&quot;, greet());
}
</code></pre></pre>
<p>We have created a new function again with <code>fn</code>, but this time we've added the
symbol <code>-&gt;</code> to introduce the type(s) that the function returns, plus the keyword
<code>String</code> meaning our function returns a string (technically transfering
<em>ownership</em> of a heap allocated and growable vector of bytes representing a
valid string encoded as UTF-8, but we'll come back to that!). The last
expression in a function if it doesn't end with a semi-colon is used as the
return value without needing the <code>return</code> keyword. This seems a bit random at
first, but it will make more sense as we find out more about the language. For
now we'll stick to this convention for very short functions.</p>
<p>The <code>println!</code> macro takes a format string literal as the first argument,
followed by zero or more values that are used by that format string. In our case
the format string contains <code>{}</code> to embed the value returned from our <code>hello</code>
function formatted simply as a string.</p>
<p>Tests can be added to the same file:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::greet;

    #[test]
    fn test_greet() {
        assert_eq!(greet(), &quot;Hello, world!&quot;);
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>Before we delve into what's going on here let's run the tests: run <code>cargo test</code>
from your terminal - you should see a successful test run with 1 passing test.</p>
<p>The first line is a directive to the compiler meaning that the following item
will only be compiled when running the tests. That item is a <em>sub-module</em> - a
module within the module defined by our <code>main.rs</code> file. We've followed the
convention of calling our sub-module &quot;tests&quot;, so it does what it says on the
tin! Next the <code>use</code> statement is <em>used</em> to bring the greet function into the
scope of our sub-module.</p>
<p>The function with the <code>#[test]</code> annotation is where the testing action begins.
The annotation is used by the test runner to identify which function(s) should
be run as tests. The
<a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a> macro is part
of standard library for testing equality between two values. In this case we are
asserting the actual value returned from our function matches the expected
value.</p>
<p>Notice that when it comes to testing Rust is a batteries included language -
everything you need to get started is included in the language and standard
tools. Also of note is that while there is a little boilerplate required to
separate your testing code, test's are concise with very little ceremony
required.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        
                            <a rel="next" href="chapter_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
                    <a rel="next" href="chapter_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
